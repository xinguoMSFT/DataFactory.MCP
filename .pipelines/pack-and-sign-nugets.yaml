#################################################################################
#                               OneBranch Pipelines                             #
# Pack and Sign DataFactory.MCP NuGet Packages                                  #
# Documentation:  https://aka.ms/obpipelines                                    #
# Yaml Schema:    https://aka.ms/obpipelines/yaml/schema                        #
# Retail Tasks:   https://aka.ms/obpipelines/tasks                              #
# Support:        https://aka.ms/onebranchsup                                   #
#################################################################################

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - DataFactory.MCP/*

pr:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - DataFactory.MCP/*

parameters:
  - name: "debug"
    displayName: "Enable debug output"
    type: boolean
    default: false

variables:
  CDP_DEFINITION_BUILD_COUNT: $[counter('', 0)] # needed for onebranch.pipeline.version task
  system.debug: ${{ parameters.debug }}
  ENABLE_PRS_DELAYSIGN: 1
  BuildConfiguration: "Release"
  DataFactorySourceDir: ""
  REPOROOT: $(Build.SourcesDirectory)
  # Use backslash form to avoid mixed-separator issues on Windows
  OUTPUTROOT: $(Build.SourcesDirectory)\out
  WindowsContainerImage: "onebranch.azurecr.io/windows/ltsc2022/vse2022:latest"

resources:
  repositories:
    - repository: templates
      type: git
      name: OneBranch.Pipelines/GovernedTemplates
      ref: refs/heads/main

extends:
  template: v2/OneBranch.Official.CrossPlat.yml@templates
  parameters:
    featureFlags:
      WindowsHostVersion: "1ESWindows2022"

    globalSdl:
      tsa:
        enabled: true
      credscan:
        enabled: true
      policheck:
        enabled: true
        break: false
      armory:
        enabled: true
        break: true
      binskim:
        enabled: true
        break: true
      suppression:
        suppressionFile: $(Build.SourcesDirectory)/.gdn/build.official.gdnsuppress
      baseline:
        baselineFile: $(Build.SourcesDirectory)/.gdn/build.official.gdnbaselines

    stages:
      - stage: build
        jobs:
          - job: main
            pool:
              type: windows

            variables:
              ob_outputDirectory: "$(Build.SourcesDirectory)/out"
              ob_sdl_binskim_break: true
              ob_symbolsPublishing_enabled: true
              ob_nugetPublishing_enabled: true
              # Force NuGet to use only our config
              NUGET_PACKAGES: "$(Agent.TempDirectory)/.nuget/packages"
              DOTNET_SKIP_FIRST_TIME_EXPERIENCE: "true"
              DOTNET_CLI_TELEMETRY_OPTOUT: "true"

            steps:
              # Setup .NET
              - task: UseDotNet@2
                displayName: "Install .NET SDK"
                inputs:
                  packageType: "sdk"
                  version: "10.0.x"
                  includePreviewVersions: true

              # Restore packages using standard dotnet restore
              - task: DotNetCoreCLI@2
                displayName: "Restore packages"
                inputs:
                  command: "restore"
                  projects: "$(Build.SourcesDirectory)/DataFactory.MCP/DataFactory.MCP.csproj"
                  feedsToUse: "config"
                  nugetConfigPath: "$(Build.SourcesDirectory)/nuget.config"
                  verbosityRestore: "Normal"
                  noCache: true
                retryCountOnTaskFailure: 3

              # Build the project using standard dotnet build
              - task: DotNetCoreCLI@2
                displayName: "Build project"
                inputs:
                  command: "build"
                  projects: "$(Build.SourcesDirectory)/DataFactory.MCP/DataFactory.MCP.csproj"
                  arguments: "--configuration $(BuildConfiguration) --no-restore"

              # Sign binary files (following OneBranch.Official.yml pattern)
              - task: onebranch.pipeline.signing@1
                displayName: "Sign binary files"
                inputs:
                  command: "sign"
                  signing_profile: "external_distribution"
                  files_to_sign: |
                    **/*.exe;
                    **/*.dll;
                    **/*.ps1;
                    **/*.psm1;
                    **/*.psd1;
                    !**/ModelContextProtocol.dll;
                    !**/ModelContextProtocol.Core.dll;
                    !**/Microsoft.Extensions.*.dll;
                    !**/Microsoft.Identity.Client.dll;
                    !**/System.*.dll;
                  search_root: "$(Build.SourcesDirectory)\\DataFactory.MCP\\bin\\$(BuildConfiguration)\\net10.0"

              # Sign 3rd party dlls (following OneBranch.Official.yml pattern)
              - task: onebranch.pipeline.signing@1
                displayName: "Sign 3rd party dlls"
                inputs:
                  command: "sign"
                  signing_profile: "135020002"
                  files_to_sign: |
                    **/ModelContextProtocol.dll;
                    **/ModelContextProtocol.Core.dll;
                  search_root: "$(Build.SourcesDirectory)\\DataFactory.MCP\\bin\\$(BuildConfiguration)\\net10.0"

              # Verify signatures after signing (pre-pack)
              - task: PowerShell@2
                displayName: "Verify signed binaries (pre-pack)"
                inputs:
                  targetType: inline
                  script: |
                    $root = "$(Build.SourcesDirectory)\DataFactory.MCP\bin\$(BuildConfiguration)\net10.0"
                    Write-Host "Checking signatures under $root"
                    $targets = Get-ChildItem $root -Recurse -Filter *.dll | Where-Object { $_.Name -in @('DataFactory.MCP.dll','ModelContextProtocol.dll','ModelContextProtocol.Core.dll') }
                    if (-not $targets) { Write-Error "No target assemblies found to verify." }
                    $unsigned = @()
                    foreach ($f in $targets) {
                      $sig = Get-AuthenticodeSignature -FilePath $f.FullName
                      $subject = if ($sig.SignerCertificate) { $sig.SignerCertificate.Subject } else { '<none>' }
                      $thumb = if ($sig.SignerCertificate) { $sig.SignerCertificate.Thumbprint } else { '<none>' }
                      Write-Host ("{0} => Status={1}; Thumbprint={2}; Subject={3}" -f $f.Name, $sig.Status, $thumb, $subject)
                      if ($sig.Status -ne 'Valid') { $unsigned += $f }
                    }
                    if ($unsigned.Count -gt 0) {
                      Write-Warning "The following files are still unsigned prior to pack:"; $unsigned | ForEach-Object { Write-Warning $_.FullName }
                    }

              # Pack the project using standard dotnet pack with nobuild to preserve signatures
              - task: DotNetCoreCLI@2
                displayName: "Pack NuGet packages"
                inputs:
                  command: "pack"
                  packagesToPack: "$(Build.SourcesDirectory)/DataFactory.MCP/DataFactory.MCP.csproj"
                  configuration: "$(BuildConfiguration)"
                  outputDir: "$(OUTPUTROOT)"
                  nobuild: true
                  includeSymbols: true

              # Optional: Fallback post-pack signing if pre-pack signing failed (extract, sign, repack)
              - ${{ if eq(variables['ENABLE_POST_PACK_SIGNING'], 'true') }}:
                  - task: PowerShell@2
                    displayName: "(Fallback) Extract packages for post-pack signing"
                    inputs:
                      targetType: inline
                      script: |
                        $out = "$(OUTPUTROOT)"
                        $work = Join-Path $out "_extract"
                        New-Item -ItemType Directory -Force -Path $work | Out-Null
                        Get-ChildItem "$out" -Filter *.nupkg | ForEach-Object {
                          $name = $_.BaseName
                          $dest = Join-Path $work $name
                          New-Item -ItemType Directory -Force -Path $dest | Out-Null
                          Expand-Archive -Path $_.FullName -DestinationPath $dest -Force
                        }
                        Write-Host "Extracted packages to $work"
                  - task: onebranch.pipeline.signing@1
                    displayName: "(Fallback) Sign extracted binaries"
                    inputs:
                      command: sign
                      signing_profile: external_distribution
                      files_to_sign: |
                        **/DataFactory.MCP.dll;
                      search_root: "$(OUTPUTROOT)/_extract"
                  - task: onebranch.pipeline.signing@1
                    displayName: "(Fallback) Sign extracted 3rd party binaries"
                    inputs:
                      command: sign
                      signing_profile: 135020002
                      files_to_sign: |
                        **/ModelContextProtocol.dll;
                        **/ModelContextProtocol.Core.dll;
                      search_root: "$(OUTPUTROOT)/_extract"
                  - task: PowerShell@2
                    displayName: "(Fallback) Repack signed packages"
                    inputs:
                      targetType: inline
                      script: |
                        $out = "$(OUTPUTROOT)"
                        $work = Join-Path $out "_extract"
                        Get-ChildItem $work -Directory | ForEach-Object {
                          $pkgName = $_.Name + '.nupkg'
                          $dest = Join-Path $out $pkgName
                          Remove-Item $dest -ErrorAction SilentlyContinue
                          Compress-Archive -Path (Join-Path $_ '*') -DestinationPath $dest -Force
                          Write-Host "Repacked $dest"
                        }

              # Sign NuGet packages (following OneBranch.Official.yml pattern)
              - task: onebranch.pipeline.signing@1
                displayName: "Sign NuGet Packages"
                inputs:
                  command: "sign"
                  signing_profile: "external_distribution"
                  files_to_sign: "*.nupkg;"
                  search_root: "$(OUTPUTROOT)"

              # Verify packages are signed (NuGet signature + Authenticode of embedded DLLs)
              - task: PowerShell@2
                displayName: "Verify packages are signed"
                inputs:
                  targetType: inline
                  script: |
                    $out = "$(OUTPUTROOT)"
                    if (-not (Test-Path $out)) { Write-Error "Output directory '$out' does not exist"; exit 1 }
                    $pkgs = Get-ChildItem $out -Filter *.nupkg -ErrorAction SilentlyContinue
                    if (-not $pkgs) { Write-Error "No .nupkg files found in $out"; exit 1 }
                    $nugetVerifyFailures = @()
                    foreach ($pkg in $pkgs) {
                      Write-Host "Running 'dotnet nuget verify' on $($pkg.Name)" -ForegroundColor Cyan
                      $verify = & dotnet nuget verify --signatures --all $pkg.FullName 2>&1
                      $verify | ForEach-Object { Write-Host $_ }
                      if ($LASTEXITCODE -ne 0) { $nugetVerifyFailures += $pkg }
                    }
                    if ($nugetVerifyFailures.Count -gt 0) {
                      Write-Warning ("NuGet signature verification failed for: {0}" -f ($nugetVerifyFailures.Name -join ', '))
                    }

                    # Deep Authenticode verification of key assemblies inside each package
                    $authFailures = @()
                    $tempRoot = Join-Path $out "_verify_extract"
                    if (Test-Path $tempRoot) { Remove-Item $tempRoot -Recurse -Force }
                    New-Item -ItemType Directory -Path $tempRoot | Out-Null
                    $targetNames = @('DataFactory.MCP.dll','ModelContextProtocol.dll','ModelContextProtocol.Core.dll')
                    foreach ($pkg in $pkgs) {
                      $extractDir = Join-Path $tempRoot ([IO.Path]::GetFileNameWithoutExtension($pkg.Name))
                      New-Item -ItemType Directory -Path $extractDir | Out-Null
                      Expand-Archive -Path $pkg.FullName -DestinationPath $extractDir -Force
                      # Tool packages put binaries under tools/<tfm>/any (sometimes RID folder). Search broadly but narrow by names.
                      $candidates = Get-ChildItem $extractDir -Recurse -Include $targetNames -ErrorAction SilentlyContinue | Where-Object { $_.Extension -eq '.dll' }
                      if (-not $candidates) {
                        Write-Warning "No target DLLs found in $($pkg.Name) to verify (expected one of: $($targetNames -join ', '))."
                        continue
                      }
                      foreach ($dll in $candidates) {
                        $sig = Get-AuthenticodeSignature -FilePath $dll.FullName
                        $subject = if ($sig.SignerCertificate) { $sig.SignerCertificate.Subject } else { '<none>' }
                        $thumb = if ($sig.SignerCertificate) { $sig.SignerCertificate.Thumbprint } else { '<none>' }
                        Write-Host ("[{0}] {1} => Status={2}; Thumbprint={3}; Subject={4}" -f $pkg.Name, ($dll.FullName.Substring($extractDir.Length+1)), $sig.Status, $thumb, $subject)
                        if ($sig.Status -ne 'Valid') { $authFailures += [PSCustomObject]@{ Package=$pkg.Name; File=$dll.FullName; Status=$sig.Status } }
                      }
                    }
                    if ($authFailures.Count -gt 0) {
                      Write-Host "--- Authenticode Failures ---" -ForegroundColor Yellow
                      $authFailures | Format-Table -AutoSize | Out-String | Write-Host
                      Write-Error ("{0} file(s) missing valid Authenticode signature inside packages" -f $authFailures.Count)
                    }
                    elseif ($nugetVerifyFailures.Count -eq 0) {
                      Write-Host "All packages passed NuGet and Authenticode verification." -ForegroundColor Green
                    }
                # Allow pipeline to proceed so we can still collect Guardian results; fail only on unsigned internal dlls.
                continueOnError: true

              # List created packages for quick inspection
              - task: PowerShell@2
                displayName: "List created packages"
                inputs:
                  targetType: inline
                  script: |
                    $out = "$(OUTPUTROOT)"
                    if (Test-Path $out) {
                      Get-ChildItem $out -Filter *.nupkg -Recurse | Select-Object FullName, Length, LastWriteTime | Format-Table -AutoSize | Out-String | Write-Host
                    } else { Write-Host "Output directory not found: $out" }
                continueOnError: true
